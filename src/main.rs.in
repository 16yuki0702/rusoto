use std::fs::File;
use std::io::Read;
use std::collections::BTreeMap;
use regex::Regex;
use inflector::Inflector;

fn main() {

	let mut f = File::open("/home/adimarco/code/rusoto/codegen/botocore/botocore/data/dynamodb/2012-08-10/service-2.json").unwrap();
	let mut s = String::new();
	let _ = f.read_to_string(&mut s);


    let service: Service = serde_json::from_str(&s).unwrap();

    println!("#![allow(non_snake_case)]");
    //    println!("{}", render_shapes(&service));
    println!("{}", render_operations(&service));

}

// Translate botocore "operations" to Rust methods that make REST requests
fn render_operations(service: &Service) -> String {
	let mut src = String::new();

	for operation in service.operations.values() {

		src.push_str(&format!("\tpub fn {}(&mut self, input: &{}) -> {} {{\n", operation.name.to_snake_case(), operation.input.shape, operation.output.shape));
		src.push_str("\t\tlet encoded = serde_json::to_string(&input).unwrap();\n");
		src.push_str(&format!("\t\tlet mut request = SignedRequest::new(\"{}\", \"{}\", &self.region, \"{}\");\n", operation.http.method, service.metadata.endpointPrefix, operation.http.requestUri));
		src.push_str("\t\trequest.set_content_type(\"application/x-amz-json-1.0\".to_string());\n");
		src.push_str(&format!("\t\trequest.add_header(\"x-amz-target\", \"{}.{}\");\n", service.metadata.targetPrefix, operation.name));
		src.push_str("\t\trequest.set_payload(Some(encoded.as_bytes()));\n");
		src.push_str("\t\tlet mut result = request.sign_and_execute(try!(self.creds.get_credentials()));\n");
		src.push_str("\t\tlet status = result.status.to_u16();\n");
		src.push_str("\t\tlet mut body = String::new();\n");
		src.push_str("\t\tresult.read_to_string(&mut body).unwrap();\n");
		src.push_str("\t\tmatch status {\n");
		src.push_str("\t\t\t200 => {\n");
		src.push_str(&format!("\t\t\t\tlet decoded: {} = serde_json::from_str(&body).unwrap();\n", operation.output.shape));
		src.push_str("\t\t\t\tOk(decoded)\n");
		src.push_str("\t\t\t}\n");
		src.push_str("\t\t\t_ => {\n");
		src.push_str("\t\t\t\tErr(parse_error(&body))\n");
		src.push_str("\t\t\t}\n");
		src.push_str("\t\t}\n");
		src.push_str("\t}\n");

	}

	src
}

// Translate botocore "shapes" to Rust types
fn render_shapes(service: &Service) -> String {

	let mut src = String::new();

    for (name, shape) in service.shapes.iter() {

    	// String is already a type in Rust
    	if name == "String" {
    		continue;
    	}

    	if shape.shape_type == "structure" {
    		src = src + &format!("{}\n", struct_type(name, &shape));
    	} else {
    		let rust_type = match &*shape.shape_type {
    			"structure" => struct_type(name, &shape),
    			"map" => format!("::std::collections::HashMap<{},{}>", shape.key(), shape.value()),
    			"list" => format!("Vec<{}>", shape.member()),
    			_ => primitive_type(&shape.shape_type)
    		};

    		src = src + &format!("pub type {} = {};\n", name, rust_type);
    	}
    }
    src
}


fn struct_type(name: &str, shape: &Shape) -> String {
	if shape.members.is_empty() {
		return format!("pub struct {};", name);
	}

	let mut struct_type = format!("pub struct {} {{\n", name);
	for (member_name, member) in shape.members.iter() {
		if member.documentation.is_some() {
			//struct_type = struct_type + "\t// documentation\n";
		}

		if shape.required(member_name) {
			struct_type = struct_type + &format!("\tpub {}: {},\n", member_name, member.shape);
		} else {
			struct_type = struct_type + &format!("\tpub {}: Option<{}>,\n", member_name, member.shape)
		}


	}

	struct_type = struct_type + "}\n";
	struct_type


}


fn primitive_type(shape_type: &str) -> String {
	match shape_type {
		"string" => "String".to_string(),
		"integer" => "i32".to_string(),		
		"long" => "i64".to_string(),
		"float" => "f32".to_string(),
		"double" => "f64".to_string(),
		"blob" => "Vec<u8>".to_string(),
		"boolean" => "bool".to_string(),
		// yes, this is a float type for a timestmap.
		// that's how it comes back from AWS
		"timestamp" => "f64".to_string(),
		_ => panic!(format!("Unknown type '{}'", shape_type))
	}
}


#[derive(Serialize, Deserialize, Debug)]
struct Service {
	version: String,
	metadata: Metadata,
	documentation: Option<String>,
	operations: BTreeMap<String, Operation>,
	shapes: BTreeMap<String, Shape>,
	examples: BTreeMap<String, String>
}

#[derive(Serialize, Deserialize, Debug)]
struct HttpRequest {
	method: String,
	requestUri: String
}

#[derive(Serialize, Deserialize, Debug)]
struct InputOutput {
	shape: String,
	documentation: Option<String>
}

#[derive(Serialize, Deserialize, Debug)]
struct Error {
	shape: String,
	exception: bool,
	fault: Option<bool>,
	documentation: Option<String>
}

#[derive(Serialize, Deserialize, Debug)]
struct Member {
	shape: String,
	documentation: Option<String>
}

#[derive(Serialize, Deserialize, Debug)]
struct Key {
	shape: String
}


#[derive(Serialize, Deserialize, Debug)]
struct Value {
	shape: String
}

#[derive(Serialize, Deserialize, Debug)]
struct Shape {
	#[serde(rename="type")]
	shape_type: String,
	#[serde(rename="enum")]
	shape_enum: Vec<String>,
	required: Option<Vec<String>>,
	members: BTreeMap<String, Member>,
	member: Option<Member>,
	key: Option<Key>,
	value: Option<Value>,
	min: Option<i32>,
	max: Option<i32>,
	pattern: Option<String>,
	exception: Option<bool>,
	fault: Option<bool>,
	documentation: Option<String>
}

impl<'a> Shape {
	fn key(&'a self) -> &'a str {
		&self.key.as_ref().expect("Key shape undefined").shape
	}

	fn value(&'a self) -> &'a str {
		&self.value.as_ref().expect("Value shape undefined").shape
	}

	fn member(&'a self) -> &'a str {
		&self.member.as_ref().expect("Member shape undefined").shape
	}

	fn required(&self, field: &'a str) -> bool {
		self.required.is_some() && self.required.as_ref().unwrap().contains(&String::from(field))
	}
}

#[derive(Serialize, Deserialize, Debug)]
struct Operation {
	name: String,
	http: HttpRequest,
	input: InputOutput,
	output: InputOutput,
	errors: Vec<Error>,
	documentation: Option<String>
}

#[derive(Serialize, Deserialize, Debug)]
struct Metadata {
	apiVersion: String,
    endpointPrefix: String,
    jsonVersion: String, 
    serviceAbbreviation: String,
    serviceFullName: String,
    signatureVersion: String,
    targetPrefix: String,
    protocol: String
}

